---
title: "Review in R"
output: html_document
date: "2024-06-05"
---

```{r}
if (!require("palmermpenguins")) install.packages("palmermpenguins")
if (!require("gridExtra")) install.packages("gridExtra")

library(palmerpenguins)
library(tidyverse)
library(ggpubr)
```

# Introduction

Welcome to the `Statistical Modeling with R` workshop! In this workshop, we will go over different stages in statistical modeling with emphasis on coding in R. We will first review some of the core packages in the `tidyverse` framework, such as `dplyr` and `ggplot2`, which are used for data cleaning and data exploration. After that, we will apply statistical tests and create statistical model using functions from the `stats` package, which come with base R. Emphasis of this workshop will not be on the theoretical footing of these tests. Rather, we will learn the common syntax in R for running the statistical models and learn to leverage tools from `tidyverse` to check assumptions and visualize the model.

This markdown document is part 1 of this workshop, which is a review of `tidyverse`.

# Data

For the majority of this workshop, we will be working with the `penguins` dataset from `palmerpenguins` package.

```{r}
head(penguins)
```

`glimpse()` is also a useful function to get a quick rundown of all the columns in the data frame you're working with.

```{r}
glimpse(penguins)
```

# Steps in Statistical Modeling Process

1.  Define the research question and design the study
2.  Collect data
3.  Clean and explore data
    -   Missing data
    -   Outliers
    -   Descriptive Statistics
4.  Choose and fit a statistical test or model
5.  Evaluate and criticize the fit of model
6.  Draw inference

# Quick Review of R

Being able to utilize core functions of R as well as the data manipulation language in `tidyverse` is an essential skill for statistical analysis. Rarely do you start with the dataset that is clean and ready for analysis, and often you will need to go back after modelling after evaluating the model fit.

## Data Manipulation with `dplyr` and `tidyr`

Piping operator `%>%` (or `|>`, which is available in base R as of R 4.1.0) is a syntax often used in tidyverse workflow. It allows you to chain multiple functions together, passing the output of one function to the next. While you could achieve the same functionality by enclosing one function within another, multiple levels of nesting can make the code difficult to read.

```{r, eval=FALSE}
# with piping
data %>%
  func1() %>%
  func2() %>%
  func3()

# without piping
func3(func2(func1(data)))
```

You can select columns with `select()` function.

```{r}
penguins %>%
  select(species, island, bill_length_mm) %>%
  head()
```

Filter rows with the `filter()` function with filter criteria inside the function.

```{r}
penguins %>% 
  select(species, island, bill_length_mm) %>%
  filter(species == "Adelie", island == "Torgersen", bill_length_mm > 45)
```

You can create new columns or replace existing ones with `mutate()` function.

```{r}
penguins %>%
  select(species, sex) %>%
  # create a new column to flag missing sex
  mutate(missing_sex = is.na(sex)) %>%
  head(10)
```

You can group data with `group_by()` function and summarize data with `summarize()` function.

```{r}
penguins %>%
  group_by(species, island) %>%
  summarize(
    n = n(), # number of rows
    mean_bill_length = mean(bill_length_mm), # mean of bill length
    sd_bill_length = sd(bill_length_mm) # standard deviation of bill length
  )
```

If I were to work naively with the data set, this would already show me that I'll have to do something with the missing values.

If you have attended the R Intermediate Tidyverse workshop, you would have also encountered reshaping functions such as `pivot_longer()` and `pivot_wider()`. You may find these functions useful when you need to visualize the data in a certain way, or if you are working with repeated measures data (i.e. multiple measurements for each subject).

```{r}
glimpse(billboard)

billboard %>%
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    values_to = "rank"
  )
```

This is a good time to mention [select helper functions](https://dplyr.tidyverse.org/reference/select.html) that helps with easily selecting multiple columns that conform to a certain pattern. For example, `starts_with("wk")` lets me select all columns that start with `"wk"`.

There are many other functions in these packages that are useful for data manipulation. There may be more functions that I use in this workshop that I have not covered here, but I will do my best to explain as I go along.

## Exercise 1

Select observations where `sex` is not missing and from `Biscoe` island. Then count the number of rows from each species within `Biscoe`.

```{r}
penguins %>% 
  filter(is.na(!sex) & island == "Biscoe") %>%
  group_by(species) %>%
  summarise(n = n())
```

Bonus: Use `pivot_longer()` to transform the penguins data such that each observation is a measurement from one of `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, or `body_mass_g` variable. Name the new column containing the variable as `variable` and the column containing the value as `measurement`.

For example, the value of `variable` and `measurement` in the first row are `bill_length_mm` and `39.1`, respectively, and the second row would be `bill_depth_mm` and `18.7` respectively.

Hint: imagine the variables as different "timepoints".

```{r}
penguins %>%
  pivot_longer(
    cols = c("bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g"),
    names_to = "variable",
    values_to = "measurement"
  )
```

## Data Visualization with ggplot2

Visualizing your data is a great way to understand the shape and trends in your data. Many statistical models and tests assume that your data is distributed in a certain way, and visualizing your data can help you determine if your data meets these assumptions.

For visualization, we will be using the `ggplot2` package. `ggplot2` is covered in our R Fundamentals workshop, which you can access through [this link](https://github.com/nuitrcs/R-fundamentals-summer-workshop). The basic idea of `ggplot2` is to iteratively add "layers" to change different components of the plot.

With `geom_*()` functions, you can choose the type of plot you would like to show (e.g. `geom_point()` for scatter plot, `geom_boxplot()` for boxplot). You can set axis scales with `xlim()`, `ylim()`, or `coord_cartesian()`. You can use `facet_grid()` or `facet_wrap()` to break down your plots into smaller subsets.

First let's create a simple scatter plot between two continuous variables.

```{r}
ggplot(penguins) +
  geom_point(aes(x = bill_length_mm, y = bill_depth_mm))
```

You can add color to the points to represent different groups by specifying `color=` inside the `aes()` function.

```{r}
# color by species
ggplot(penguins) +
  geom_point(aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  ggtitle("Bill Length vs Bill Depth", "by Species")

# color by island
ggplot(penguins) +
  geom_point(aes(x = bill_length_mm, y = bill_depth_mm, color = island)) +
  ggtitle("Bill Length vs Bill Depth", "by Island")
```

Let's try faceting the plot by year and look at body mass across species.

```{r}
ggplot(penguins) +
  geom_boxplot(aes(x = species, y = body_mass_g)) +
  facet_wrap(~year) +
  ggtitle("Body Mass by Species", "Faceted by Year") +
  xlab("Species") +
  ylab("Boddy Mass (g)")
```

## Exercise 2

Plot the relationship between `species` and `body_mass_g`.

Plot the relationship between `bill_depth` and `body_mass_g`. Color the points by `sex` variable.

# Cleaning and Summarizing Data

## Data types

Data can come in a number of different types, and this can influence the type of visualization and model that you use. Largely there are two types of variables: **continuous** (or quantitative) and **categorical** variable.

**Continuous variables** are numerical values that can change continuously. Example of continuous variables are weight, height, and price. In the `penguins` data, `bill_length_mm` and `bill_depth_mm` are examples of continuous variables.

**Categorical variables** are types of variables that can be split into distinct categories or labels that represent different groups. They can be ordered (Ordinal) or non-ordered (Nominal). In the `penguins` data, `species` and `island` are examples of categorical variables.

When you start working with a data, one of the first things you want to do is get an idea of which data is continuous or categorical. This is often clear from reading the documentation on the data set or taking a quick look at the data.

```{r}
glimpse(penguins)
```

In R, you'll often see that the continuous variables are often represented by a `double` or `integer` data type. The categorical variables are often represented by `factor` or `character`. The type is shown within the angled brackets when using `glimpse()`.

For categorical variables, if you know what the possible categories are, it is often advantageous to convert the `character` data types to `factor`.

-   This can potentially save lots of memory if you are dealing with lots of observations
-   It protects you from inadvertently introducing a new category, which you might not have accounted for in your model.
-   When visualizing, you can decide the ordering of the categories

Ultimately, which variable you would like to treat as category vs continuous depends on how you would like to characterize the data. For example, let's look at `year`.

```{r}
print(class(penguins$year))
unique(penguins$year)
```

Although the data type is `integer` and I could interpret this as a continuous data, we only have three distinct years, and instead of the trend over time, I might just be interested in characterizing the effect of each year. In this context, I might set `year` as factor instead of keeping it as `integer`.

## Missing Data

1.  Missing Completely at Random (MCAR)
2.  Missing at Random (MAR)
3.  Missing Not at Random (MNAR)

```{r}
# select any rows with missing data
penguins %>% 
  filter(if_any(everything(), is.na))
```

```{r}
# check relationship between numeric variable and missingness in sex
penguins %>%
  # convert NA to a factor level
  mutate(sex = fct_na_value_to_level(sex)) %>%
  # pivot the table so that each row is a measurement of a variable 
  # for each observation
  pivot_longer(
    cols = c(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g),
    names_to = "variable",
    values_to = "value"
  ) %>%
  # plot distribution of each variable by sex status
  ggplot() +
  facet_wrap(~variable, scales = "free_y") +
  geom_boxplot(aes(x = sex, y = value)) +
  geom_jitter(aes(x = sex, y = value), alpha = 0.1, width = 0.3) +
  ggtitle("Distribution of Numeric Variables")
```

## Exercise 3: Compare Missingness in Categorical Variables

```{r}
# check relationship between numeric variable and missingness in sex
penguins  %>%
  # convert year to factor
  mutate(year = as.factor(year)) %>%
  # pivot the table so that each row is a measurement of a variable 
  # for each observation
  pivot_longer(
    cols = c(year, species, island),
    names_to = "variable",
    values_to = "value"
  ) %>%
  count(variable, value, missing_sex = is.na(sex)) %>%
  # plot distribution of each variable by sex status
  ggplot() +
  facet_wrap(~variable, scales = "free") +
  geom_col(aes(x = value, y = n, fill = missing_sex), position = position_dodge(preserve = "single"))
```

No apparent trend in missing values. Potentially missing value is related to sex variable? Will need advise from domain expert who was involved in data collection.

```{r}
# drop observations with NA
pgns <- penguins %>% drop_na()
dim(pgns)
```

# Getting to Know Your Data a Little Better

## Descriptive Statistics

You often want to get descriptive statistics of the data as a quick summary. You can also do quick group comparisons by utilizing the `group_by()` and `summarise()` functions from `dplyr`.

Here are some useful functions for summarizing data: `mean()`, `sd()`, `median()`, `quantile()`, `min()`, `max()`.

```{r}
pgns %>%
  group_by(island, species, sex) %>%
  summarise(
    n = n(),
    across(
      .cols = c(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g), 
      .fns = list(mean = mean, sd = sd))
  )
```

Mean is commonly used to characterize the central tendency of the data. Be careful, though: mean is sensitive to outliers, so if you have data with outliers that is causing a heavy skew (i.e. not symmetrically distributed), you will want to use the median, which is more robust.

How do we determine if there's a skew or extreme outliers? This is where visualization comes in handy.

## Data Visualization

Depending on the type of variable you're exploring, you want to use different type of visualization. In this step, you are looking to understand the distribution of variables and relationship between them.

### Distribution of a Continuous Variable

When it comes to looking at a distribution of a continuous variable, you can use a histogram. This plot shows the distribution by binning across the continuous scale and showing the frequency within each bin. You should choose the width of the bin so that it best characterizes your data. Choose a width too wide, you will be masking some important trends; choose a width too small, you might not get enough samples in each bin to show meaning pattern.

```{r}
ggplot(pgns) +
  geom_histogram(aes(bill_length_mm)) +
  ggtitle("Histogram of Bill Length (mm)")
```

```{r}
g1 <- ggplot(pgns) +
  geom_histogram(aes(bill_length_mm), binwidth = 5) +
  ggtitle("Histogram of Bill Length (mm)", "binwidth = 5")
g2 <- ggplot(pgns) +
  geom_histogram(aes(bill_length_mm), binwidth = 1) +
  ggtitle("Histogram of Bill Length (mm)", "binwidth = 1")
g3 <- ggplot(pgns) +
  geom_histogram(aes(bill_length_mm), binwidth = 0.5) +
  ggtitle("Histogram of Bill Length (mm)", "binwidth = 0.5")
g4 <- ggplot(pgns) +
  geom_histogram(aes(bill_length_mm), binwidth = 0.1) +
  ggtitle("Histogram of Bill Length (mm)", "binwidth = 0.1")

ggarrange(g1, g2, g3, g4)
```

An alternative to histogram is a density plot. This type of plot can be thought of as smoothed histogram. The smoothness of the density can be controlled by an argument `bw=`. The higher the value is, the more the density will look smoother. By default this is chosen for you by an algorithm.

```{r}
ggplot(pgns) +
  geom_density(aes(x = bill_length_mm))
```

## Exercise 4

Try different `bw=` to see how it affects the density plot.

```{r}
ggplot(pgns) +
  geom_density(aes(x = bill_length_mm), bw = 0.1)
```

You can easily compare the distribution across different groups by specifying `fill=`.

```{r}
g1 <- ggplot(pgns) +
  geom_histogram(aes(x = bill_length_mm, fill = species)) +
  ggtitle("Distribution of Bill Length (mm)", "Color by Species")

g2 <- ggplot(pgns) +
  geom_density(aes(x = bill_length_mm, fill = species)) +
  ggtitle("Distribution of Bill Length (mm)", "Color by Species")

ggarrange(g1, g2, nrow = 1, common.legend = TRUE)
```

Alternatively, to compare distribution of a continuous variable across groups (continuous vs categorical), you can make a box plot or violin plot.

```{r}
g1 <- ggplot(pgns) +
  geom_boxplot(
    aes(x = species, y = bill_length_mm, fill = island), 
    position = position_dodge2(preserve = "single")
  ) +
  ggtitle("Distribution of Bill Length (mm)", "Color by Species")

g2 <- ggplot(pgns) +
  geom_violin(
    aes(x = species, y = bill_length_mm, fill = island)
  ) +
  ggtitle("Distribution of Bill Length (mm)", "Color by Species")

ggarrange(g1, g2, nrow = 1, common.legend = TRUE)
```

## Comparing Two Continuous Variables

You can produce a scatter plot for comparing two continuous variables.

```{r}
ggplot(pgns) +
  geom_point(aes(x = bill_length_mm, y = bill_depth_mm))
```

```{r}
ggplot(pgns) +
  geom_point(aes(x = bill_length_mm, y = body_mass_g, color = species))
```

## Bonus: Plot Descriptive Statistics

Finally, there is one more useful feature in ggplot that you can add to your arsenal. This is `stat_summary()`.

If I want to create a plot comparing the means across different groups (for example, crossing between sex and species), I might approach it the following way. Here, I transformed the original data set in such a way that I have the mean and standard deviation for each group, and then used the resulting data set to plot the means with +- 1 std using `geom_point()` and `geom_errorbar()`.

```{r}
# calculate group means and standard deviation
pgns %>%
  group_by(species, sex) %>%
  summarise(
    mean_body_mass = mean(body_mass_g),
    sd_body_mass = sd(body_mass_g)
  ) %>%
  ggplot() +
  geom_point(aes(x = species, y = mean_body_mass, color = sex)) +
  geom_errorbar(aes(
    x = species, 
    ymin = mean_body_mass - sd_body_mass, 
    ymax = mean_body_mass + sd_body_mass, 
    color = sex
  ))
```

`stat_summary()` takes your original data, summarizes the data using the desired function, and plots based on the summarized output. Grouping structure can be defined by `x` and other mapping aesthetics such as `color`, `fill`, `shape`, etc.

The `fun=` argument takes in a function used to summarize the data, and `geom=` defines what geometric object is used to display the data. The values for `geom=` are what you see in the `geom_*()` functions. For example, to plot a point for the transformed data, you can set `geom="point"`.

```{r}
ggplot(pgns, aes(x = species, y = body_mass_g, color = sex)) +
  stat_summary(fun = mean, geom = "point") +
  stat_summary(fun.data = "mean_sd", geom = "errorbar", width = 0.2)
```

```{r}
ggplot(pgns, aes(x = species, y = body_mass_g, fill = sex)) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.95)) +
  stat_summary(fun.data = "mean_sd", geom = "errorbar", width = 0.2, position = position_dodge(0.95))
```
